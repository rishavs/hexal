[--
    Hey there, Welcome to the HExal language!
    Hexal is a statically and strongly typed language with a syntax which resembles some of the languages that you are already familiar with, like Typescript, Haxe, C99 etc - but a fully compiled backend.
    Hexal aims to be super simple and super boring. It doesn't have any new mind-bending concept which would change all programming languages or help me do a PhD. But its tiny, modern and adheres very tightly to "1 way of doing a thing" zen. Hexal's main focus is instead on learning from other languages and on giving a great dev-exp.
    
    The major features of Hexal are:
    1. Simple and tiny syntax
    2. Strong type system inspired by that of Typescript and Crystal
    3. Value Types!
    4. simple OOPs  
    5. Coroutines
    6. Destructuring
    7. 1 based arrays
    6. LLVM backend to emit fast executables
    and a Package Manager to tie all this up!
    
    
    This files aims to give a quick tour of the (WIP) Hexal language (and a quick test file for me to test against the compiler!). 
    This is an executable tutorial.  You can compile and run it using the Hexal compiler. 
    
    Look for the slash-star marks surrounding these paragraphs.  We are inside
    a "Multiline comment".  We can leave some notes here that will get ignored
    by the compiler.

   Multiline comments are also used to generate javadoc-style documentation for
   haxedoc.  They will be used for haxedoc if they immediately precede a class,
   class function, or class variable. 
--] 

-- Double dashes like this will give a single-line comment.


a1 = 10     -- We can also add comments within lines like this.

a2 = 10
a3: Int = 30

a4, a5 = 40, 50  -- Hexal allows for multiple returns and multiple assignments

b1: Bool = true

b2 = fn (a: INt, b: Int) -> Int {
    return a + b
}

b3 = class {
    b4 = 10
    b5: Bool
    @new = fn () -> {
    
    }
    b6 = fn (isTrue: Bool) -> Bool {
        return true
    }
}



